# 使用队列实现栈

## 原题 leetcode 255

使用队列实现栈的下列操作：

- push(x) -- 元素 x 入栈
- pop() -- 移除栈顶元素
- top() -- 获取栈顶元素
- empty() -- 返回栈是否为空

**注意:**

- 你只能使用队列的基本操作-- 也就是 `push to back`, `peek/pop from front`, `size`, 和 `is empty` 这些操作是合法的。
- 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
- 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

## 队列

队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。

队列之所以被称为队列，是因为这种数据结构类似排队机制，新来的人只能排在队伍的尾端，而队首的人一定最先排好队，故而队列的数据是先进先出的。

![未标题-1](https://gitee.com/peng_zhi_hung/img-res/raw/master/%E6%9C%AA%E6%A0%87%E9%A2%98-1.png)

在 C++ 的 STL 中已经封装好了 queue 队列的数据结构，如果需要使用则需要导入 queue 头文件：

```c++
#include<queue>
```

C++ 的 queue 的相关类成员函数如下：

> back() 返回最后一个元素，只是返回不进行删除操作
>
> empty() 如果队列空则返回真
>
> front() 返回第一个元素，仅仅返回也不进行删除
>
> pop() 删除第一个元素
>
> push() 在末尾加入一个元素
>
> size() 返回队列中元素的个数

## 栈

栈（Stack）又名堆栈，它是一种重要的数据结构。从数据结构角度看，栈也是线性表，其特殊性在于栈的基本操作是线性表操作的子集，它是操作受限的线性表，因此，可称为限定性的数据结构。限定它仅在表尾进行插入或删除操作。表尾称为栈顶，相应地，表头称为栈底。栈的基本操作除了在栈顶进行插入和删除外，还有栈的初始化，判空以及取栈顶元素等。

栈与队列相反，它的数据是后进先出的。

![demo1_画板 2](https://gitee.com/peng_zhi_hung/img-res/raw/18ea3c41b8771ded4812ab82f43379dc6e4b9c52/demo1_%E7%94%BB%E6%9D%BF%202.png)

如上图所示，`push`操作的元素会堆放在栈内元素的上方，最上方的元素为栈顶（top），`pop`会弹出栈顶元素，若弹栈后，栈内最上层元素成为新的栈顶。

C++ 的 STL 也已经封装好了 stack 栈的数据结构，如果需要使用也先要导入 stack 的相关头文件：

```c++
#include<stack>
```

C++ 的 stack 相关成员函数如下：

> empty() 堆栈为空则返回真
>
> pop() 移除栈顶元素
>
> push() 在栈顶增加元素
>
> size() 返回栈中元素数目
>
> top() 返回栈顶元素

## 队列实现栈的操作

如果队列需要实现栈的操作，那么我们需要考虑模拟弹栈时如何能使队尾的元素先弹出，以及`top()`即取栈顶元素时如何取出我们保存在队列的队尾元素，保存元素时正常保存到队列里与保存到栈中差异并不太大。

### 方法一

这个方法的思路是每次保存到队列的元素与上次保存到队列的元素进行颠倒一下，类似于将原本顺序顺放的元素进行一次反序操作，那么原本队首元素就会成为颠倒后的队尾元素，由于栈的出栈顺序是后进先出、先进后出，而队列的出队操作则是先进先出，所以颠倒后的顺序正是出栈的顺序。

例，如下这两幅图中的出队顺序为A、B、C，而出栈顺序是C、B、A，出栈顺序的确与出队顺序相反。

![未标题-1](https://gitee.com/peng_zhi_hung/img-res/raw/master/%E6%9C%AA%E6%A0%87%E9%A2%98-1.png)

![demo1_画板 2](https://gitee.com/peng_zhi_hung/img-res/raw/18ea3c41b8771ded4812ab82f43379dc6e4b9c52/demo1_%E7%94%BB%E6%9D%BF%202.png)

现在我们考虑如何使队列中的元素反序。